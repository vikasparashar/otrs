.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Simple 3"
.TH Simple 3 "2013-10-07" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::IMAP::Simple \- Perl extension for simple IMAP account handling.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use strict;
\&    use warnings;
\&    use Net::IMAP::Simple;
\&    use Email::Simple;
\&
\&    # Create the object
\&    my $imap = Net::IMAP::Simple\->new(\*(Aqimap.example.com\*(Aq) ||
\&       die "Unable to connect to IMAP: $Net::IMAP::Simple::errstr\en";
\&
\&    # Log on
\&    if(!$imap\->login(\*(Aquser\*(Aq,\*(Aqpass\*(Aq)){
\&        print STDERR "Login failed: " . $imap\->errstr . "\en";
\&        exit(64);
\&    }
\&
\&    # Print the subject\*(Aqs of all the messages in the INBOX
\&    my $nm = $imap\->select(\*(AqINBOX\*(Aq);
\&
\&    for(my $i = 1; $i <= $nm; $i++){
\&        if($imap\->seen($i)){
\&            print "*";
\&        } else {
\&            print " ";
\&        }
\&
\&        my $es = Email::Simple\->new(join \*(Aq\*(Aq, @{ $imap\->top($i) } );
\&
\&        printf("[%03d] %s\en", $i, $es\->header(\*(AqSubject\*(Aq));
\&    }
\&
\&    $imap\->quit;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a simple way to access \s-1IMAP\s0 accounts.
.SH "OBJECT CREATION METHOD"
.IX Header "OBJECT CREATION METHOD"
.Vb 1
\&    my $imap = Net::IMAP::Simple\->new( $server [ :port ]);
\&
\&    # OR
\&
\&    my $imap = Net::IMAP::Simple\->new( $server [, option_name => option_value ] );
.Ve
.SS "new"
.IX Subsection "new"
This class method constructs a new Net::IMAP::Simple object. It takes one
required parameter which is the server to connect to, and additional optional
parameters.
.PP
The server parameter may specify just the server, or both the server and port
number. To specify an alternate port, separate it from the server with a colon
(\f(CW\*(C`:\*(C'\fR), \f(CW\*(C`example.com:5143\*(C'\fR.
.PP
On success an object is returned. On failure, nothing is returned and an error
message is set to \f(CW$Net::IMAP::Simple\fR.
.PP
See \*(L"\s-1PREAUTH\s0\*(R" below for a special hostname invocation that doesn't use Sockets
(internally).
.PP
Options are provided as a hash to \f(CW\*(C`new()\*(C'\fR:
.IP "port => int" 4
.IX Item "port => int"
Assign the port number (default: 143)
.IP "timeout => int (default: 90)" 4
.IX Item "timeout => int (default: 90)"
Connection timeout in seconds.
.IP "retry => int (default: 1)" 4
.IX Item "retry => int (default: 1)"
Attempt to retry the connection attmpt (x) times before giving up
.IP "retry_delay => int (default: 5)" 4
.IX Item "retry_delay => int (default: 5)"
Wait (x) seconds before retrying a connection attempt
.IP "use_v6 => \s-1BOOL\s0" 4
.IX Item "use_v6 => BOOL"
If set to true, attempt to use IPv6 sockets rather than IPv4 sockets.
.Sp
This option requires the IO::Socket::INET6 module
.IP "use_ssl => \s-1BOOL\s0" 4
.IX Item "use_ssl => BOOL"
If set to true, attempt to use IO::Socket::SSL sockets rather than vanilla sockets.
.Sp
Note that no attempt is made to check the certificate validity by default.  This
is terrible personal security but matches the previous behavior of this module.
Please consider using \f(CW\*(C`find_ssl_defaults\*(C'\fR below.
.Sp
This option requires the IO::Socket::SSL module
.IP "ssl_version => version" 4
.IX Item "ssl_version => version"
This should be one or more of the following (space separated): SSLv3 SSLv2
TLSv1.  If you specify, for example, \*(L"SSLv3 SSLv2\*(R" then IO::Socket::SSL will
attempt auto negotiation.  At the time of this writing, the default string was
v3/v2 auto negotiation \*(-- it may have changed by the time you read this.
.Sp
Warning: setting this will also set \f(CW\*(C`use_ssl\*(C'\fR.
.IP "find_ssl_defaults => []" 4
.IX Item "find_ssl_defaults => []"
Looks in some standard places for \s-1CA\s0 certificate libraries and if found sets
reasonable defaults along the lines of the following.
.Sp
.Vb 2
\&    ssl_options => [ SSL_ca_path => "/etc/ssl/certs/",
\&        SSL_verify_mode => IO::Socket::SSL::SSL_VERIFY_PEER() ]
.Ve
.Sp
Warning: setting this will also set \f(CW\*(C`use_ssl\*(C'\fR.
.IP "ssl_options => []" 4
.IX Item "ssl_options => []"
You may provide your own IO::Socket::SSL options if you desire to do so.
It is completely overridden by \f(CW\*(C`find_ssl_defaults\*(C'\fR above.
.IP "bindaddr => str" 4
.IX Item "bindaddr => str"
Assign a local address to bind
.IP "use_select_cache => \s-1BOOL\s0" 4
.IX Item "use_select_cache => BOOL"
Enable \f(CW\*(C`select()\*(C'\fR caching internally
.IP "select_cache_ttl => int" 4
.IX Item "select_cache_ttl => int"
The number of seconds to allow a select cache result live before running
\&\f(CW\*(C`$imap\-\*(C'\fR\fIselect()\fR> again.
.IP "debug => \s-1BOOL\s0 | \e*HANDLE | warn | file:name" 4
.IX Item "debug => BOOL | *HANDLE | warn | file:name"
Enable debugging output. If \f(CW\*(C`\e*HANDLE\*(C'\fR is a valid file handle, debugging will
be written to it.  If it is the string \f(CW"warn"\fR then the debugging will be
written using the warn command.  If it is a string of the form \f(CW\*(C`file:name\*(C'\fR
then the named file will be opened for append and the debugs written to it.
Otherwise debugging will be written to \f(CW\*(C`STDOUT\*(C'\fR
.IP "readline_callback => \s-1CODE\s0" 4
.IX Item "readline_callback => CODE"
You may choose to pass a callback function for the purpose of pre-processing
lines before they are handed to the rest of the Net::IMAP::Simple internals.
This can be handy for animating a spinner or modifying the \s-1IMAP\s0 behavior.
.SH "PREAUTH"
.IX Header "PREAUTH"
Rather than passing a port number and issuing a login, in some situations it may
be convenient to authenticate with (for example) ssh and simply invoke (for
example) dovecot by hand.
.PP
If the server name starts with \f(CW\*(C`cmd:\*(C'\fR, then Net::IMAP::Simple will issue the
command rather than building sockets.  This is a typical setup:
.PP
.Vb 3
\&    my $cmd = "ssh \-C mailhost dovecot \-\-exec\-mail imap";
\&    my $imap = Net::IMAP::Simple\->new("cmd:$cmd");
\&     # $imap\->login(); ... don\*(Aqt need this
\&
\&    my $number_of_messages = $imap\->select("INBOX");
.Ve
.SH "METHODS"
.IX Header "METHODS"
.IP "starttls" 4
.IX Item "starttls"
.Vb 1
\&    $imap\->starttls;
.Ve
.Sp
If you start an \s-1IMAP\s0 session and wish to upgrade to \s-1SSL\s0 later, you can use this
function to start \s-1TLS\s0.  This function will try to \f(CW\*(C`require\*(C'\fR IO::Socket::SSL
and Net::SSLeay at runtime.
.IP "login" 4
.IX Item "login"
.Vb 1
\&  my $inbox_msgs = $imap\->login($user, $passwd);
.Ve
.Sp
This method takes two required parameters, a username and password. This pair is
authenticated against the server. If authentication is successful \s-1TRUE\s0 (1) will
be returned
.Sp
Nothing is returned on failure and the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the
error message.
.IP "status" 4
.IX Item "status"
.Vb 2
\&    my $num_messages                     = $imap\->status($folder);
\&    my ($unseen, $recent, $num_messages) = $imap\->status($folder);
.Ve
.Sp
Issue a \f(CW\*(C`STATUS\*(C'\fR command.  The \f(CW\*(C`STATUS\*(C'\fR command counts messages without
altering the state of the named (optionally) mailbox.  It returns either the
number of messages, or the number of unseen messages, recent, and the total
number of messages.
.Sp
\&\f(CW$folder\fR is an optional argument.  \f(CW\*(C`status()\*(C'\fR will use the current mailbox or
\&\f(CW\*(C`INBOX\*(C'\fR if the \f(CW$folder\fR argument is not provided.
.Sp
This method does not use caching.
.Sp
This method can also query custom status values.  The first argument to the
function (if any) is assumed to be the folder name, so the folder argument is
required when trying to query custom status values.
.Sp
.Vb 2
\&    my ($f1, $f2) = $imap\->status($folder, qw(f1 f2));
\&    my $f2        = $imap\->status($folder, qw(f1 f2));
.Ve
.IP "uidnext" 4
.IX Item "uidnext"
.Vb 1
\&    my $uidnext = $imap\->uidnext($folder);
.Ve
.Sp
Return the \f(CW\*(C`UIDNEXT\*(C'\fR value for a mailbox.  The \f(CW$folder\fR argument is optional.
This is really just an alias for
.Sp
.Vb 1
\&    my $uidnext = $imap\->status($folder, qw(uidnext));
.Ve
.Sp
with the mild difference that it can compute the folder argument for you
.IP "uidvalidity" 4
.IX Item "uidvalidity"
.Vb 1
\&    my $uidvalidity = $imap\->uidnext($folder);
.Ve
.Sp
Return the \f(CW\*(C`UIDVALIDITY\*(C'\fR value for a mailbox.  The \f(CW$folder\fR argument is
optional.  This is also an alias for the status call like \f(CW\*(C`uidnext()\*(C'\fR above.
.IP "uid" 4
.IX Item "uid"
.Vb 2
\&    my $uid = $imap\->uid($msgno);
\&    my @uid = $imap\->uid($msg_range); # eg 4:14  or 15,4,14
.Ve
.Sp
Return the \f(CW\*(C`UID\*(C'\fR value(s) for a message.  These unique IDs "\fImust\fR\*(L" stay the
same during the session and \*(R"\fIshould\fR" stay the same between sessions.  Whether
they stay the same depends on the \f(CW\*(C`UIDVALIDITY\*(C'\fR value; see: above and \s-1RFC3501\s0.
.Sp
Warning, although you might thing \f(CW@uid\fR should contain the \f(CW\*(C`UID\*(C'\fRs for 15,
then 4, then 14 in the example above; most \s-1IMAP\s0 servers seem to return the UIDs
in increasing order.  Normally the sequence numbers are in increasing order
also, so it all maches up.
.Sp
.Vb 1
\&    my ($uid4, $uid14, $uid15) = $imap\->uid("15,4,14"); # warning
.Ve
.Sp
This function is actually an alias for \f(CW\*(C`$imap\->uidsearch($msg_range)\*(C'\fR.
.IP "seq" 4
.IX Item "seq"
.Vb 2
\&    my $seq = $imap\->seq($uids);
\&    my @seq = $imap\->seq($uids); # eg 58888:58900
.Ve
.Sp
Rather like \f(CW\*(C`uid()\*(C'\fR above, but maps uids to sequence numbers.
.IP "select" 4
.IX Item "select"
.Vb 1
\&    my $num_messages = $imap\->select($folder);
.Ve
.Sp
Selects a folder named in the single required parameter. The number of messages
in that folder is returned on success. On failure, nothing is returned  and the
\&\f(CW\*(C`errstr()\*(C'\fR error handler is set with the error message.
.IP "examine" 4
.IX Item "examine"
This is very nearly a synonym for \f(CW\*(C`select()\*(C'\fR.  The only real difference is that
the \s-1EXAMINE\s0 command is sent to the server instead of \s-1SELECT\s0.
Net::IMAP::Simple is otherwise unaware of the read-only-ness of the mailbox.
.IP "close" 4
.IX Item "close"
.Vb 1
\&    $imap\->close;
.Ve
.Sp
Un-selects the current mailbox, leaving no mailbox selected.
.IP "messages" 4
.IX Item "messages"
.Vb 1
\&    print "Messages in Junk Mail \-\- " . $imap\->messages("INBOX.Junk Mail") .  "\en";
.Ve
.Sp
This method is an alias for \f(CW\*(C`$imap\-\*(C'\fRselect>
.IP "flags" 4
.IX Item "flags"
.Vb 1
\&    print "Available server flags: " . join(", ", $imap\->flags) . "\en";
.Ve
.Sp
This method accepts an optional folder name and returns the current available
server flags as a list, for the selected folder. If no folder name is provided
the last folder \f(CW\*(C`$imap\->select\*(C'\fR'ed will be used.
.Sp
This method uses caching.
.IP "separator" 4
.IX Item "separator"
Returns the folder separator (technically \*(L"hierarchy separator\*(R", rfc3501X6.3.8)
for the server.
.IP "recent" 4
.IX Item "recent"
.Vb 1
\&    print "Recent messages value: " . $imap\->recent . "\en";
.Ve
.Sp
This method accepts an optional folder name and returns the '\s-1RECENT\s0' value
provided durning a \s-1SELECT\s0 result set. If no folder name is provided the last
folder \f(CW\*(C`$imap\->select\*(C'\fR'ed will be used.
.Sp
This method uses caching.
.Sp
See also: search
.IP "unseen" 4
.IX Item "unseen"
.Vb 1
\&    print "Unseen messages value: " . $imap\->unseen . "\en";
.Ve
.Sp
This method accepts an optional folder name and returns the '\s-1UNSEEN\s0' value
provided during a \s-1SELECT\s0 command result. If no folder name is provided the last
folder \f(CW\*(C`$imap\->select\*(C'\fR'ed will be used.  If a folder name \fIis\fR provided,
this will issue a \s-1SELECT\s0 first.
.Sp
This method uses caching.
.Sp
If the server does not provide \s-1UNSEEN\s0 during \s-1SELECT\s0 \*(-- surprisingly common \*(--
this method will fall back and use \s-1STATUS\s0 to determine the unseen count.
.Sp
\&\fB\s-1NOTE\s0\fR: This is not the opposite of seen below.  The \s-1UNSEEN\s0 value varies
from server to server, but according to the \s-1IMAP\s0 specification, it should be the
\&\fInumber of the first unseen message\fR, in the case the flag is provided.  (If
the flag is not provided, users would have to use the \s-1SEARCH\s0 command to find it.)
.Sp
See also: search
.IP "current_box" 4
.IX Item "current_box"
.Vb 1
\&   print "Current Mail Box folder: " . $imap\->current_box . "\en";
.Ve
.Sp
This method returns the current working mail box folder name.
.IP "top" 4
.IX Item "top"
.Vb 1
\&    my $header = $imap\->top( $message_number ); print for @{$header};
.Ve
.Sp
This method accepts a message number as its required parameter. That message
will be retrieved from the currently selected folder. On success this method
returns a list reference containing the lines of the header. Nothing is returned
on failure and the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the error message.
.IP "seen" 4
.IX Item "seen"
.Vb 3
\&    defined( my $seen = $imap\->seen( $message_number ) )
\&        or warn "problem testing for \eSeen: "
\&              . $imap\->errstr;
\&
\&    print "msg #$message_number has been \eSeen!" if $seen;
.Ve
.Sp
A message number is the only required parameter for this method.  The message's
\&\f(CW\*(C`\eSeen\*(C'\fR flag will be examined and if the message has been seen a true value is
returned.  A defined false value is returned if the message does not have the
\&\f(CW\*(C`\eSeen\*(C'\fR flag set.  The undefined value is returned when an error has occurred
while checking the flag status.
.Sp
\&\fB\s-1NOTE\s0\fR: This is not the opposite of unseen above.  This issues a \f(CW\*(C`FETCH\*(C'\fR
command and checks to see if the given message has been \f(CW\*(C`\eSeen\*(C'\fR before.
.IP "deleted" 4
.IX Item "deleted"
.Vb 3
\&    defined( my $deleted = $imap\->deleted( $message_number ) )
\&        or warn "problem testing for \eDeleted: "
\&              . $imap\->errstr;
\&
\&    print "msg #$message_number has been \eDeleted!" if $deleted;
.Ve
.Sp
A message number is the only required parameter for this method.  The message's
\&\f(CW\*(C`\eDeleted\*(C'\fR flag will be examined and if the message has been deleted a true
value is returned.  A defined false value is returned if the message does not
have the \f(CW\*(C`\eDeleted\*(C'\fR flag set.  The undefined value is returned when an error
has occurred while checking the flag status.
.IP "list" 4
.IX Item "list"
.Vb 2
\&    my $message_size  = $imap\->list($message_number);
\&    my $mailbox_sizes = $imap\->list;
.Ve
.Sp
This method returns size information for a message, as indicated in the single
optional parameter, or all messages in a mailbox. When querying a single message
a scalar value is returned. When listing the entire mailbox a hash is returned.
On failure, nothing is returned and the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the
error message.
.IP "get" 4
.IX Item "get"
.Vb 2
\&  my $message = $imap\->get( $message_number ) or die $imap\->errstr;
\&  my @message_lines = $map\->get( $message_number ) or die $imap\->errstr;
\&
\&  my $part = $imap\->get( $message_number, \*(Aq1.1\*(Aq ) or die $imap\->errstr;
\&  my @part_lines = $imap\->get( $message_number, \*(Aq1.1\*(Aq ) or die $imap\->errstr;
.Ve
.Sp
This method fetches a message and returns its lines as an array or, the actual
message.  On failure, either an empty list is returned and the \f(CW\*(C`errstr()\*(C'\fR error
handler is set with the error message.
.Sp
Optionally, a part can be specified in order to fetch a specific portion of a
message.  This is the raw, encoded body of the message part.  The part number
is a set of zero or more part specifiers delimited by periods.  Every message
has at least one part.  Specifying a part of '1' returns the raw, encoded
body.  This is only useful if you know the header information such as encoding.
.Sp
Historically, \f(CW\*(C`get()\*(C'\fR returned the array of lines as a reference to the array
instead of returning the message or the array itself.  Please note that it still
does this, although it may be deprecated in the future.
.Sp
The scalar result returned is actually a blessed arrayref with the stringify
member overloaded.  If you're intending to use the resulting message as a string
more than once, it \fImay\fR make sense to force the stringification first.
.Sp
.Vb 2
\&    my $message = $imap\->get(1);
\&       $message = "$message"; # force stringification
.Ve
.Sp
It is not normally necessary to do this.
.IP "put" 4
.IX Item "put"
.Vb 1
\&  $imap\->put( $mailbox_name, $message, @flags ) or warn $imap\->errstr;
.Ve
.Sp
Save a message to the server under the folder named \f(CW$mailbox_name\fR.  You may
optionally specify flags for the mail (e.g. \f(CW\*(C`\eSeen\*(C'\fR, \f(CW\*(C`\eAnswered\*(C'\fR), but they
must start with a slash.
.Sp
If \f(CW$message\fR is an arrayref, the lines will be printed correctly.
.IP "msg_flags" 4
.IX Item "msg_flags"
.Vb 2
\&    my @flags = $imap\->msg_flags( $message_number );
\&    my $flags = $imap\->msg_flags( $message_number );
\&
\&    # aught to come out roughly the same
\&    print "Flags on message #$message_number: @flags\en";
\&    print "Flags on message #$message_number: $flags\en";
.Ve
.Sp
Detecting errors with this member functions is usually desirable.  In the scalar
context, detecting an error is synonymous with testing for defined.
.Sp
.Vb 2
\&    if( defined( my $flags = $imap\->msg_flags($num) ) ) {
\&        # it has $flags!
\&
\&    } else {
\&        warn "problem listing flags for message #$num: "
\&           . $imap\->errstr;
\&    }
.Ve
.Sp
In list context, you must call waserr() to test for success.
.Sp
.Vb 3
\&    my @flags = $imap\->msg_flags($num);
\&    warn "problem listing flags for msg #$num: "
\&       . $imap\->errstr if $imap\->waserr;
.Ve
.IP "getfh" 4
.IX Item "getfh"
.Vb 1
\&  my $file = $imap\->getfh( $message_number ); print <$file>;
.Ve
.Sp
On success this method returns a file handle pointing to the message identified
by the required parameter. On failure, nothing is returned and the \f(CW\*(C`errstr()\*(C'\fR
error handler is set with the error message.
.IP "quit" 4
.IX Item "quit"
.Vb 1
\&  $imap\->quit;
\&
\&  OR
\&
\&  $imap\->quit(BOOL);
.Ve
.Sp
This method logs out of the \s-1IMAP\s0 server, expunges the selected mailbox, and
closes the connection. No error message will ever be returned from this method.
.Sp
Optionally if \s-1BOOL\s0 is \s-1TRUE\s0 (1) then a hard quit is performed which closes the
socket connection. This hard quit will still issue both \s-1EXPUNGE\s0 and \s-1LOGOUT\s0
commands however the response is ignored and the socket is closed after issuing
the commands.
.IP "logout" 4
.IX Item "logout"
.Vb 1
\&  $imap\->logout;
.Ve
.Sp
This method is just like the quit method except that it does not have a hard
quit option and it does not expunge the mailbox before it hangs up and closes
the socket.
.IP "last" 4
.IX Item "last"
.Vb 1
\&  my $message_number = $imap\->last;
.Ve
.Sp
This method returns the message number of the last message in the selected
mailbox, since the last time the mailbox was selected. On failure, nothing is
returned and the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the error message.
.IP "delete" 4
.IX Item "delete"
.Vb 1
\&  print "Gone!" if $imap\->delete( $message_number );
.Ve
.Sp
This method sets the \f(CW\*(C`\eDeleted\*(C'\fR flag on the given message (or messages). On
success it returns true, false on failure and the \f(CW\*(C`errstr()\*(C'\fR error handler is
set with the error message.  If the flag was already there, no error is
produced.  I takes either a message number or \*(L"sequence set\*(R" as the only
argument.  Note that messages aren't actually deleted until they are expunged
(see expunge_mailbox).
.IP "undelete" 4
.IX Item "undelete"
.Vb 1
\&  print "Resurrected!" if $imap\->undelete( $message_number );
.Ve
.Sp
This method removes the \f(CW\*(C`\eDeleted\*(C'\fR flag on the given message. On success it
returns true, false on failure and the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the
error message.  If the flag wasn't there, no error is produced.
.IP "see" 4
.IX Item "see"
.Vb 1
\&  print "You\*(Aqve seen message #$msgno" if $imap\->see( $messageno );
.Ve
.Sp
This method sets the \f(CW\*(C`\eSeen\*(C'\fR flag on the given message. On success it returns
true, false on failure and the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the error
message.  If the flag was already there, no error is produced.
.IP "unsee" 4
.IX Item "unsee"
.Vb 1
\&  print "You\*(Aqve not seen message #$msgno" if $imap\->unsee( $messageno );
.Ve
.Sp
This method removes the \f(CW\*(C`\eSeen\*(C'\fR flag on the given message. On success it
returns true, false on failure and the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the
error message.  If the flag wasn't there, no error is produced.
.IP "add_flags" 4
.IX Item "add_flags"
delete and see above really just call this function for those flags.
.Sp
.Vb 2
\&   $imap\->add_flags( $msgno, qw(\eSeen \eDeleted) )
\&        or die $imap\->errstr;
.Ve
.IP "sub_flags" 4
.IX Item "sub_flags"
unsee above really just calls this function for that flag.
.Sp
.Vb 1
\&   $imap\->sub_flags( $msgno, \*(Aq\eSeen\*(Aq ) or die $imap\->errstr;
.Ve
.IP "mailboxes" 4
.IX Item "mailboxes"
.Vb 3
\&  my @boxes   = $imap\->mailboxes;
\&  my @folders = $imap\->mailboxes("Mail/%");
\&  my @lists   = $imap\->mailboxes("lists/perl/*", "/Mail/");
.Ve
.Sp
This method returns a list of mailboxes. When called with no arguments it
recurses from the \s-1IMAP\s0 root to get all mailboxes. The first optional argument is
a mailbox path and the second is the path reference. \s-1RFC\s0 3501 section 6.3.8 has
more information.
.Sp
On failure nothing is returned and the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the
error message.
.IP "mailboxes_subscribed" 4
.IX Item "mailboxes_subscribed"
.Vb 3
\&  my @boxes   = $imap\->mailboxes_subscribed;
\&  my @folders = $imap\->mailboxes_subscribed("Mail/%");
\&  my @lists   = $imap\->mailboxes_subscribed("lists/perl/*", "/Mail/");
.Ve
.Sp
This method returns a list of mailboxes subscribed to. When called with no
arguments it recurses from the \s-1IMAP\s0 root to get all mailboxes. The first
optional argument is a mailbox path and the second is the path reference. \s-1RFC\s0
3501 has more information.
.Sp
On failure nothing is returned and the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the
error message.
.IP "create_mailbox" 4
.IX Item "create_mailbox"
.Vb 1
\&  print "Created" if $imap\->create_mailbox( "/Mail/lists/perl/advocacy" );
.Ve
.Sp
This method creates the mailbox named in the required argument. Returns true on
success, false on failure and the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the error
message.
.IP "expunge_mailbox" 4
.IX Item "expunge_mailbox"
.Vb 2
\&  my @expunged = $imap\->expunge_mailbox( "/Mail/lists/perl/advocacy" );
\&  die $imap\->errstr if $imap\->waserr;
\&
\&  my $expunged = $imap\->expunge_mailbox( "/Mail/lists/perl/advocacy" )
\&      or die $imap\->errstr;
.Ve
.Sp
This method removes all mail marked as deleted in the mailbox named in the
required argument. Returns either the number of messages that were expunged, or
the indexes of those messages \*(-- which has a questionable usefulness since it
tends to return numbers that don't relate to the message numbers marked with the
\&\f(CW\*(C`\eDeleted\*(C'\fR flags.
.Sp
If 0 messages were expunged without error, the function will return \f(CW0E0\fR so it
will still test true, but also evaluate to 0.
.Sp
In list context, you must call waserr() to test for success.
.IP "delete_mailbox" 4
.IX Item "delete_mailbox"
.Vb 1
\&  print "Deleted" if $imap\->delete_mailbox( "/Mail/lists/perl/advocacy" );
.Ve
.Sp
This method deletes the mailbox named in the required argument. Returns true on
success, false on failure and the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the error
message.
.IP "rename_mailbox" 4
.IX Item "rename_mailbox"
.Vb 1
\&  print "Renamed" if $imap\->rename_mailbox( $old => $new );
.Ve
.Sp
This method renames the mailbox in the first required argument to the mailbox
named in the second required argument. Returns true on success, false on failure
and the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the error message.
.IP "folder_subscribe" 4
.IX Item "folder_subscribe"
.Vb 1
\&  print "Subscribed" if $imap\->folder_subscribe( "/Mail/lists/perl/advocacy" );
.Ve
.Sp
This method subscribes to the folder. Returns true on success, false on failure
and the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the error message.
.IP "folder_unsubscribe" 4
.IX Item "folder_unsubscribe"
.Vb 1
\&  print "Unsubscribed" if $imap\->folder_unsubscribe( "/Mail/lists/perl/advocacy" );
.Ve
.Sp
This method un-subscribes to the folder. Returns true on success, false on
failure and the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the error message.
.IP "copy" 4
.IX Item "copy"
.Vb 1
\&  print "copied" if $imap\->copy( $message_number, $mailbox );
.Ve
.Sp
This method copies the message number (or \*(L"sequence set\*(R") in the currently
selected mailbox to the folder specified in the second argument.  Both arguments
are required.  On success this method returns true. Returns false on failure and
the \f(CW\*(C`errstr()\*(C'\fR error handler is set with the error message.
.IP "uidcopy" 4
.IX Item "uidcopy"
.Vb 1
\&  print "copied" if $imap\->uidcopy( $message_uid, $mailbox );
.Ve
.Sp
This method is identical to \f(CW\*(C`copy()\*(C'\fR above, except that it uses \s-1UID\s0 numbers
instead of sequence numbers.
.IP "noop" 4
.IX Item "noop"
.Vb 1
\&  $imap\->noop;
.Ve
.Sp
Performs a null operation.  This may be needed to get updates on a
mailbox, or ensure that the server does not close the connection as
idle.  \s-1RFC\s0 3501 states that servers' idle timeouts must not be less
than 30 minutes.
.IP "errstr" 4
.IX Item "errstr"
.Vb 1
\& print "Login ERROR: " . $imap\->errstr . "\en" if !$imap\->login($user, $pass);
.Ve
.Sp
Return the last error string captured for the last operation which failed.
.IP "waserr" 4
.IX Item "waserr"
.Vb 2
\& my @flags = $imap\->msg_flags(14);
\& die $imap\->errstr if $imap\->waserr;
.Ve
.Sp
Because \f(CW\*(C`msg_flags()\*(C'\fR can optionally return a list, it's not really possible to
detect failure in list context.  Therefore, you must call \f(CW\*(C`waserr()\*(C'\fR if you
wish to detect errors.
.Sp
Few of the Net::IMAP::Simple methods use \f(CW\*(C`waserr()\*(C'\fR.  The ones that do will
mention it.
.IP "list2range" 4
.IX Item "list2range"
Sometimes you have a long list of sequence numbers which are consecutive
and really want to be an IMAP-style range.
.Sp
.Vb 2
\&    my @list  = (5..9, 13..38, 55,56,57);
\&    my $short = $imap\->list2range(@list);
\&
\&    # $short how says: 5:9,13:38,55:57
.Ve
.IP "range2list" 4
.IX Item "range2list"
Pretty much the opposite of \f(CW\*(C`list2range\*(C'\fR.
.Sp
.Vb 2
\&    my @list = $imap\->range2list("1,3,5:9");
\&    # @list is (1,3,5,6,7,8,9);
.Ve
.SH "SEARCHING"
.IX Header "SEARCHING"
.IP "search" 4
.IX Item "search"
This function returns an array of message numbers (in list context) or the
number of matched messages (in scalar context).  It takes a single argument: the
search.
.Sp
\&\s-1IMAP\s0 searching can be a little confusing and this function makes no attempt to
parse your searches.  If you wish to do searches by hand, please see \s-1RFC\s0 3501.
.Sp
\&\s-1IMAP\s0 sorting (see \s-1RFC\s0 5256) is supported via an optional second argument.  The
\&\s-1RFC\s0 requires the charset be specified, which can be provided via the optional
third argument (defaults to \s-1UTF\-8\s0).
.Sp
Here are a few examples:
.Sp
.Vb 4
\&    my @ids = $imap\->search("UNSEEN");
\&    my @ids = $imap\->search(\*(AqSUBJECT "blarg is \e"blarg\e""\*(Aq);
\&    my @ids = $imap\->search(\*(AqFROM "joe@aol.com"\*(Aq);
\&    my @ids = $imap\->search("DELETED");
\&
\&    # example from RFC 3501, search terms are ANDed together
\&    my @ids = $imap\->search(\*(AqFLAGGED SINCE 1\-Feb\-1994 NOT FROM "Smith"\*(Aq);
\&    # example from RFC 3501, search terms are ORed together
\&    my @ids = $imap\->search(\*(AqOR BODY "blard" SUBJECT "blarg"\*(Aq);
\&
\&    # flagged and ( since x or !from y ):
\&    my @ids = $imap\->search(\*(AqFLAGGED OR SINCE x NOT FROM "y"\*(Aq);
\&      # no typo above, see the RFC
\&
\&    # example from RFC 5256, sorted by subject and reverse date
\&    my @ids = $imap\->search(\*(AqBODY "zaphod"\*(Aq, \*(AqSUBJECT REVERSE DATE\*(Aq);
.Ve
.Sp
Since this module is meant to be simple, Net::IMAP::Simple has a few search
helpers.  If you need fancy booleans and things, you'll have to learn search.
If you need a quick search for unseen messages, see below.
.Sp
These all return an array of messages or count of messages exactly as the search
function does.  Some of them take arguments, some do not.  They do try to grok
your arguments slightly, the mechanics of this (if any) will be mentioned below.
.RS 4
.IP "search_seen" 4
.IX Item "search_seen"
Returns numbers of messages that have the \eSeen flag.
.IP "search_recent" 4
.IX Item "search_recent"
Returns numbers of messages that have the \eRecent flag.
.IP "search_answered" 4
.IX Item "search_answered"
Returns numbers of messages that have the \eAnswered flag.
.IP "search_deleted" 4
.IX Item "search_deleted"
Returns numbers of messages that have the \eDeleted flag.
.IP "search_flagged" 4
.IX Item "search_flagged"
Returns numbers of messages that have the \eFlagged flag.
.IP "search_draft" 4
.IX Item "search_draft"
Returns numbers of messages that have the \eDraft flag.
.IP "search_unseen" 4
.IX Item "search_unseen"
Returns numbers of messages that do not have the \eSeen flag.
.IP "search_old" 4
.IX Item "search_old"
Returns numbers of messages that do not have the \eRecent flag.
.IP "search_unanswered" 4
.IX Item "search_unanswered"
Returns numbers of messages that do not have the \eAnswered flag.
.IP "search_undeleted" 4
.IX Item "search_undeleted"
Returns numbers of messages that do not have the \eDeleted flag.
.IP "search_unflagged" 4
.IX Item "search_unflagged"
Returns numbers of messages that do not have the \eFlagged flag.
.IP "search_smaller" 4
.IX Item "search_smaller"
This function takes a single argument we'll call \f(CW\*(C`<x>\*(C'\fR and returns numbers
of messages that are smaller than \f(CW\*(C`<x>\*(C'\fR octets.  This function will try to
force your argument to be a number before passing it to the \s-1IMAP\s0 server.
.IP "search_larger" 4
.IX Item "search_larger"
This function takes a single argument we'll call \f(CW\*(C`<x>\*(C'\fR and returns numbers
of messages that are larger than \f(CW\*(C`<x>\*(C'\fR octets.  This function will try to
force your argument to be a number before passing it to the \s-1IMAP\s0 server.
.IP "search_from" 4
.IX Item "search_from"
This function takes a single argument we'll call \f(CW\*(C`<x>\*(C'\fR and returns numbers
of messages that have \f(CW\*(C`<x>\*(C'\fR in the from header.  This function will attempt
to force your string into the \s-1RFC3501\s0 quoted-string format.
.IP "search_to" 4
.IX Item "search_to"
This function takes a single argument we'll call \f(CW\*(C`<x>\*(C'\fR and returns numbers
of messages that have \f(CW\*(C`<x>\*(C'\fR in the to header.  This function will attempt
to force your string into the \s-1RFC3501\s0 quoted-string format.
.IP "search_cc" 4
.IX Item "search_cc"
This function takes a single argument we'll call \f(CW\*(C`<x>\*(C'\fR and returns numbers
of messages that have \f(CW\*(C`<x>\*(C'\fR in the cc header.  This function will attempt
to force your string into the \s-1RFC3501\s0 quoted-string format.
.IP "search_bcc" 4
.IX Item "search_bcc"
This function takes a single argument we'll call \f(CW\*(C`<x>\*(C'\fR and returns numbers
of messages that have \f(CW\*(C`<x>\*(C'\fR in the bcc header.  This function will attempt
to force your string into the \s-1RFC3501\s0 quoted-string format.
.IP "search_subject" 4
.IX Item "search_subject"
This function takes a single argument we'll call \f(CW\*(C`<x>\*(C'\fR and returns numbers
of messages that have \f(CW\*(C`<x>\*(C'\fR in the subject header.  This function will attempt
to force your string into the \s-1RFC3501\s0 quoted-string format.
.IP "search_body" 4
.IX Item "search_body"
This function takes a single argument we'll call \f(CW\*(C`<x>\*(C'\fR and returns numbers
of messages that have \f(CW\*(C`<x>\*(C'\fR in the message body.  This function will
attempt to force your string into the \s-1RFC3501\s0 quoted-string format.
.IP "search_before" 4
.IX Item "search_before"
This function takes a single argument we'll call \f(CW\*(C`<x>\*(C'\fR and returns numbers
of messages that were received before \f(CW\*(C`<x>\*(C'\fR.  If you have Date::Manip
installed (optional), this function will attempt to force the date into the
format \f(CW\*(C`%d\-%b\-%Y\*(C'\fR (date-monthName-year) as \s-1RFC3501\s0 requires.  If you do not
have that module, no attempt will be made to coerce your date into the correct
format.
.IP "search_since" 4
.IX Item "search_since"
This function takes a single argument we'll call \f(CW\*(C`<x>\*(C'\fR and returns numbers
of messages that were received after \f(CW\*(C`<x>\*(C'\fR.  If you have Date::Manip
installed (optional), this function will attempt to force the date into the
format \f(CW\*(C`%d\-%m\-%Y\*(C'\fR (date-month-year) as \s-1RFC3501\s0 requires.  If you do not have
that module, no attempt will be made to coerce your date into the correct
format.
.IP "search_sent_before" 4
.IX Item "search_sent_before"
This function takes a single argument we'll call \f(CW\*(C`<x>\*(C'\fR and returns numbers
of messages that have a header date before \f(CW\*(C`<x>\*(C'\fR.  If you have Date::Manip
installed (optional), this function will attempt to force the date into the
format \f(CW\*(C`%d\-%m\-%Y\*(C'\fR (date-month-year) as \s-1RFC3501\s0 requires.  If you do not have
that module, no attempt will be made to coerce your date into the correct
format.
.IP "search_sent_since" 4
.IX Item "search_sent_since"
This function takes a single argument we'll call \f(CW\*(C`<x>\*(C'\fR and returns numbers
of messages that have a header date after \f(CW\*(C`<x>\*(C'\fR.  If you have Date::Manip
installed (optional), this function will attempt to force the date into the
format \f(CW\*(C`%d\-%m\-%Y\*(C'\fR (date-month-year) as \s-1RFC3501\s0 requires.  If you do not have
that module, no attempt will be made to coerce your date into the correct
format.
.RE
.RS 4
.RE
.IP "uidsearch" 4
.IX Item "uidsearch"
This function works exactly like \f(CW\*(C`search()\*(C'\fR but it returns UIDs instead of
sequence numbers.  The convenient shortcuts above are not provided for it.
.SH "OTHER NOTES"
.IX Header "OTHER NOTES"
.IP "sequence set" 4
.IX Item "sequence set"
Message numbers are never checked before being passed to the \s-1IMAP\s0 server (this
is a \*(L"simple\*(R" module after all), so in most places where a message number is
required, you can instead use so-called \fIsequence sets\fR.  Examples:
.Sp
.Vb 2
\&    $imap\->copy(   "3,4,9:22", "ANOTHERBOX" ) or die $imap\->errstr;
\&    $imap\->delete( "3,4,9:22", "ANOTHERBOX" ) or die $imap\->errstr;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Creator" 4
.IX Item "Creator"
Joao Fonseca \f(CW\*(C`<joao_g_fonseca@yahoo.com>\*(C'\fR
.IP "Maintainer 2004" 4
.IX Item "Maintainer 2004"
Casey West \f(CW\*(C`<casey@geeknst.com>\*(C'\fR
.IP "Maintainer 2005" 4
.IX Item "Maintainer 2005"
Colin Faber \f(CW\*(C`<cfaber@fpsn.net>\*(C'\fR
.IP "Maintainer 2009" 4
.IX Item "Maintainer 2009"
Paul Miller \f(CW\*(C`<jettero@cpan.org>\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2009\-2010 Paul Miller
Copyright (c) 2005 Colin Faber
Copyright (c) 2004 Casey West
Copyright (c) 1999 Joao Fonseca
.PP
All rights reserved. This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software.  You can redistribute it and/or
modify it under the terms of the Artistic License 2.0.
.PP
This program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.
.PP
[This software may have had previous licenses, of which the current maintainer
is completely unaware.  If this is so, it is possible the above license is
incorrect or invalid.]
.SH "BUGS"
.IX Header "BUGS"
There are probably bugs.  But don't worry, the current maintainer takes them
very seriously and will usually triage (at least) within a single day.
.PP
<https://rt.cpan.org/Dist/Display.html?Queue=Net\-IMAP\-Simple>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, Net::IMAP::Server, IO::Socket::SSL, IO::Socket::INET6
